<!doctype html>
<html>
<head>
<meta charset="utf8">
<style type="text/css">
* {border-collapse:collapse;border-collapse:collapse;
-moz-box-sizing:border-box;
-webkit-box-sizing:border-box;
box-sizing:border-box;margin:0px;padding:0px}
html,body {color:white;background-color:black;font-family:Courier;width:100%; height:100%;}
#whole {margin:auto}

@media (max-aspect-ratio: 100/120) {
    #whole {width:120vw;height:100vw}
    #canv {border:1px solid white;width:100vw;height:100vw;display:inline-block;float:left}
    #panel {border:1px solid white;width:20vw;height:100vw;display:inline-block;float:left}
}
@media (min-aspect-ratio: 100/120) {
    #whole {width:120vh;height:100vh}
    #canv {border:1px solid white;width:100vh;height:100vh;display:inline-block;float:left}
    #panel {border:1px solid white;width:20vh;height:100vh;display:inline-block;float:left}
}
#updowngradingnotice{font-size:10pt}
#averagediv{font-size:10pt}
.colordisplay{border:1px solid white;width:80px;height:20px}
.colordisplay2{border:1px solid white;width:80px;height:20px}
.borderedDiv {border:1px solid white;font-size:14px}
.redspan {color:red}
hr {border:0px, background-color:white;margin:2px;height:2px}
</style>
<script>
	
function shuffle(array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle.
  while (currentIndex != 0) {

    // Pick a remaining element.
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}

function RGB2HTML(red, green, blue)
{
    var decColor =0x1000000+ blue + 0x100 * green + 0x10000 *red ;
    return '#'+decColor.toString(16).substr(1);
}
function randomColor(){
    var c1 = 0,c2 = 0,c3 = 0
    
    while(Math.max(c1,Math.max(c2,c3)) < 128 || Math.min(c1,Math.min(c2,c3)) > 128){
        var c1 = Math.floor(Math.random()*256)
        var c2 = Math.floor(Math.random()*256)
        var c3 = Math.floor(Math.random()*256)
    }
    
    return RGB2HTML(c1,c2,c3)
}
function fillAndStroke(ctx,x,y,w,h,fillAlpha){
    ctx.globalAlpha = fillAlpha ? fillAlpha : 1
    ctx.fillRect(x,y,w,h)
    ctx.globalAlpha = 1
    ctx.strokeRect(x,y,w,h)
}
function prepareLine(ctx,x1,y1,x2,y2){
    ctx.beginPath()
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.closePath()
}
function prepareNumber(ctx,x,y,w,h,number){
    var path
    switch(number){
        case 0: 
            path = [
                [0,0],
                [0,1],
                [1,1],
                [1,0],
                [0,0],
            ];break
        case 1: 
            path = [
                [0,0.5],
                [1,0],
                [1,1],
            ];break
        case 2: 
            path = [
                [0,0],
                [1,0],
                [1,0.5],
                [0,1],
                [1,1],
            ];break
        case 3: 
            path = [
                [0,0],
                [1,0],
                [1,0.5],
                [0,0.5],
                [1,0.5],
                [1,1],
                [0,1],
            ];break
        case 4: 
            path = [
                [0,0],
                [0,0.5],
                [1,0.5],
                [0.8,0.5],
                [0.8,0],
                [0.8,1],
            ];break
        case 5: 
            path = [
                [1,0],
                [0,0],
                [0,0.5],
                [1,0.5],
                [1,1],
                [0,1],
            ];break
        case 6: 
            path = [
                [1,0],
                [0,0],
                [0,1],
                [1,1],
                [1,0.5],
                [0,0.5],
            ];break
        case 7: 
            path = [
                [0,0],
                [1,0],
                [0,1],
                [0.5,0.5],
                [0,0.5],
                [1,0.5],
            ];break
        case 8: 
            path = [
                [1,0],
                [0,0],
                [0,1],
                [1,1],
                [1,0.5],
                [0,0.5],
                [1,0.5],
                [1,0],
            ];break
        case 9: 
            path = [
                [1,0.5],
                [0,0.5],
                [0,0],
                [1,0],
                [1,1],
                [0,1],
            ];break
        
    }
    ctx.beginPath()
    ctx.moveTo(x+path[0][0]*w,y+path[0][1]*h)
    for(var i in path){
        ctx.lineTo(x+path[i][0]*w,y+path[i][1]*h)
    }
}
function prepareDanger(ctx,x,y,w,h){
    fillAndStroke(ctx,x,y,w,h*0.6)
    fillAndStroke(ctx,x,y+h*0.7,w,h*0.3)
}
function prepareStar(ctx,x,y,w,h){
    path = [
        [0.5,0],
        [0.8,0.3],
        [1,0.3],
        [0.9,0.5],
        [1,1],
        [0.5,0.8],
        [0,1],
        [0.1,0.5],
        [0,0.3],
        [0.2,0.3],
    ];
    ctx.beginPath()
    ctx.moveTo(x+path[0][0]*w,y+path[0][1]*h)
    for(var i in path){
        ctx.lineTo(x+path[i][0]*w,y+path[i][1]*h)
    }
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
    
}
class Square{
    constructor(x,y,parent){
        this.x = x
        this.y = y
        this.parent = parent
        
        this.color = null
        this.ares = null
        
        this.land = false
        
        this.hill = 0
        
        this.cityVillage = 0
        
        this.unit = null
        
        this.leaveArea = false
        this.area = null
        this.landWaterArea = null
        
        this.fortification = false
        this.fortificationColor = null
        
        this.hillColorTranslate = {
            0:'#aaa',
            1:'#bbb',
            2:'#ccc',
            3:'#ddd',
            4:'#d8d8d8',
            5:'#eee',
        }
        
        this.debug = null
    }
    truceColor(x,y){
        if(x == undefined)
            x = this.x
        if(y == undefined)
            y = this.y
        
        if(this.parent.truces[this.parent.currentPlayer] && this.parent.truces[this.parent.currentPlayer][this.parent.board[x][y].color] >= 0)
            return '#4c4'
            
        if(this.parent.truces[this.parent.currentPlayer] && this.parent.truces[this.parent.currentPlayer][this.parent.board[x][y].color] == -1)
            return '#c44'
        
        return null
    }
    currentPlayerStrokeColor(){
        if(this.color != null && this.color == this.parent.currentPlayer) 
            return '#cc4' 
        
        var tc = this.truceColor()
        if(tc != null)
            return tc
            
        return '#444'
    }
    draw(ctx){
        var sqWidth = 1000/this.parent.boardSize
        if(this.land){
                ctx.lineWidth = 2
            if(this.color != null){
            
                ctx.fillStyle = "#fff"
                ctx.fillRect(this.x*sqWidth,this.y*sqWidth,sqWidth+1,sqWidth+1)
                
                ctx.fillStyle = this.color
                ctx.globalAlpha = 0.7
                ctx.fillRect(this.x*sqWidth,this.y*sqWidth,sqWidth+1,sqWidth+1)
                ctx.globalAlpha = 1
                
            } else {
                ctx.fillStyle = "#aaa"
                ctx.fillRect(this.x*sqWidth,this.y*sqWidth,sqWidth+1,sqWidth+1)
                
            }
            
            if(this.hill > 0){
                ctx.strokeStyle = this.currentPlayerStrokeColor()
                ctx.lineWidth = 2
                ctx.beginPath()
                ctx.moveTo((this.x+0.1)*sqWidth,(this.y+0.75)*sqWidth)
                ctx.lineTo((this.x+0.5)*sqWidth,(this.y+0.75 - this.hill*0.1)*sqWidth)
                ctx.lineTo((this.x+0.9)*sqWidth,(this.y+0.75)*sqWidth)
                ctx.stroke()
            }
            if(this.cityVillage == 1){
                ctx.strokeStyle = this.currentPlayerStrokeColor()
                ctx.lineWidth = 2
                ctx.fillStyle = this.color ? this.color : '#fff'
                ctx.beginPath()
                ctx.moveTo((this.x+0.5)*sqWidth,(this.y+0.4 - this.hill*0.1)*sqWidth)
                ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.6 - this.hill*0.1)*sqWidth)
                ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.8 - this.hill*0.1)*sqWidth)
                ctx.lineTo((this.x+0.7)*sqWidth,(this.y+0.8 - this.hill*0.1)*sqWidth)
                ctx.lineTo((this.x+0.7)*sqWidth,(this.y+0.6 - this.hill*0.1)*sqWidth)
                ctx.closePath()
                ctx.fill()
                ctx.stroke()
                
                /*if(this.color){
                    ctx.fillStyle = this.color
                    ctx.globalAlpha = 0.6
                    ctx.beginPath()
                    ctx.moveTo((this.x+0.5)*sqWidth,(this.y+0.4 - this.hill*0.1)*sqWidth)
                    ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.6 - this.hill*0.1)*sqWidth)
                    ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.8 - this.hill*0.1)*sqWidth)
                    ctx.lineTo((this.x+0.7)*sqWidth,(this.y+0.8 - this.hill*0.1)*sqWidth)
                    ctx.lineTo((this.x+0.7)*sqWidth,(this.y+0.6 - this.hill*0.1)*sqWidth)
                    ctx.closePath()
                    ctx.fill()
                    ctx.globalAlpha = 1
                    ctx.stroke()
                }*/
            } else if(this.cityVillage == 2){
                ctx.strokeStyle = '#222'
                ctx.lineWidth = 2
                ctx.fillStyle = '#555'
                ctx.beginPath()
                ctx.moveTo((this.x+0.8)*sqWidth,(this.y+0.8)*sqWidth)
                ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.lineTo((this.x+0.4)*sqWidth,(this.y+0.2)*sqWidth)
                ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.1)*sqWidth)
                ctx.lineTo((this.x+0.1)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.lineTo((this.x+0.2)*sqWidth,(this.y+0.4)*sqWidth)
                ctx.lineTo((this.x+0.3)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.closePath()
                //ctx.fill()
                ctx.stroke()
                
                ctx.beginPath()
                ctx.moveTo((this.x+0.2)*sqWidth,(this.y+0.8)*sqWidth)
                ctx.lineTo((this.x+0.8)*sqWidth,(this.y+0.2)*sqWidth)
                ctx.lineTo((this.x+0.9)*sqWidth,(this.y+0.4)*sqWidth)
                ctx.lineTo((this.x+0.6)*sqWidth,(this.y+0.1)*sqWidth)
                ctx.lineTo((this.x+0.8)*sqWidth,(this.y+0.2)*sqWidth)
                ctx.closePath()
                //ctx.fill()
                ctx.stroke()
            } else if(this.cityVillage == 3){
                ctx.strokeStyle = this.currentPlayerStrokeColor()
                ctx.fillStyle = this.color ? this.color : '#fff'
                    
                fillAndStroke(ctx,(this.x)*sqWidth,(this.y+0.2)*sqWidth,sqWidth/3,sqWidth*0.8)
                fillAndStroke(ctx,(this.x+1/3)*sqWidth,(this.y)*sqWidth,sqWidth/3,sqWidth)
                fillAndStroke(ctx,(this.x+2/3)*sqWidth,(this.y+0.3)*sqWidth,sqWidth/3,sqWidth*0.7)
                /*if(this.color){
                    ctx.fillStyle = this.color
                    fillAndStroke(ctx,(this.x)*sqWidth,(this.y+0.2)*sqWidth,sqWidth/3,sqWidth*0.8,0.6)
                    fillAndStroke(ctx,(this.x+1/3)*sqWidth,(this.y)*sqWidth,sqWidth/3,sqWidth,0.6)
                    fillAndStroke(ctx,(this.x+2/3)*sqWidth,(this.y+0.3)*sqWidth,sqWidth/3,sqWidth*0.7,0.6)
                }*/
            } else if(this.cityVillage == 4){
                ctx.strokeStyle = '#222'
                ctx.fillStyle = '#555'
                
                ctx.beginPath()
                ctx.moveTo((this.x+0.4)*sqWidth,(this.y+0.1)*sqWidth)
                ctx.lineTo((this.x+0.6)*sqWidth,(this.y+0.1)*sqWidth)
                ctx.lineTo((this.x+0.6)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.lineTo((this.x+0.8)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.lineTo((this.x+0.8)*sqWidth,(this.y+0.5)*sqWidth)
                ctx.lineTo((this.x+0.6)*sqWidth,(this.y+0.5)*sqWidth)
                ctx.lineTo((this.x+0.6)*sqWidth,(this.y+0.8)*sqWidth)
                ctx.lineTo((this.x+0.4)*sqWidth,(this.y+0.8)*sqWidth)
                ctx.lineTo((this.x+0.4)*sqWidth,(this.y+0.5)*sqWidth)
                ctx.lineTo((this.x+0.2)*sqWidth,(this.y+0.5)*sqWidth)
                ctx.lineTo((this.x+0.2)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.lineTo((this.x+0.4)*sqWidth,(this.y+0.3)*sqWidth)
                ctx.closePath()
                ctx.fill()
                ctx.stroke()
            }
        }
        
        ctx.lineWidth = 2
        ctx.strokeStyle = '#444'
        
        if(this.fortification && this.fortificationColor == this.color){
            var places = [
                [0,0],
                [0.2,0],
                [0.4,0],
                [0.6,0],
                [0.8,0],
                
                [0,0.2],
                [0,0.4],
                [0,0.6],
                
                [0,0],
                [0.2,0.8],
                [0.4,0.8],
                [0.6,0.8],
                [0.8,0.8],
                
                [0.8,0.2],
                [0.8,0.4],
                [0.8,0.6],
            ]
            for(var i in places){
                var place = places[i]
                prepareLine(ctx,(this.x+place[0])*sqWidth,(this.y+place[1])*sqWidth,(this.x+place[0]+0.2)*sqWidth,(this.y+place[1]+0.2)*sqWidth)
                ctx.stroke()
                prepareLine(ctx,(this.x+place[0]+0.2)*sqWidth,(this.y+place[1])*sqWidth,(this.x+place[0])*sqWidth,(this.y+place[1]+0.2)*sqWidth)
                ctx.stroke()
                
            }
            
        }
        ctx.lineWidth = 2
        ctx.strokeStyle = '#fff'
        
        var tc = this.truceColor()
        var borderWidth = 4
        var borderColor = '#777'
        
        var neighbors = this.parent.getDirectNeighbors(this.x,this.y)
        if(neighbors.left != null && neighbors.left.land != this.land){
            prepareLine(ctx,(this.x)*sqWidth,this.y*sqWidth,(this.x)*sqWidth,(this.y+1)*sqWidth)
            ctx.stroke()
        } else if(neighbors.left != null && neighbors.left.color != this.color && neighbors.left.land == this.land && this.land == true){
            var nc = this.truceColor(neighbors.left.x,neighbors.left.y)
            ctx.strokeStyle = tc ? tc : nc ? nc : borderColor
            ctx.lineWidth = borderWidth
            prepareLine(ctx,(this.x)*sqWidth,this.y*sqWidth,(this.x)*sqWidth,(this.y+1)*sqWidth)
            ctx.stroke()
            ctx.lineWidth = 1
            
        }
        if(neighbors.top != null && neighbors.top.land != this.land){
            prepareLine(ctx,this.x*sqWidth,(this.y)*sqWidth,(this.x+1)*sqWidth,(this.y)*sqWidth)
            ctx.stroke()
        } else if(neighbors.top != null && neighbors.top.color != this.color && neighbors.top.land == this.land && this.land == true){
            var nc = this.truceColor(neighbors.top.x,neighbors.top.y)
            ctx.strokeStyle = tc ? tc : nc ? nc : borderColor
            ctx.lineWidth = borderWidth
            prepareLine(ctx,this.x*sqWidth,(this.y)*sqWidth,(this.x+1)*sqWidth,(this.y)*sqWidth)
            ctx.stroke()
            ctx.lineWidth = 1
        }
        if(this.debug != null){
            ctx.strokeStyle = '#f00'
            prepareNumber(ctx,(this.x+0.4)*sqWidth,(this.y+0.1)*sqWidth,sqWidth*0.15+1,sqWidth*0.4+1,this.debug % 10)
            ctx.stroke()
        }
        /*
        if(this.area != null && this.area.number != undefined){
            ctx.strokeStyle = '#f00'
            var number = this.area.number
            if(number >= 10){
                prepareNumber(ctx,(this.x+0.1)*sqWidth,(this.y+0.1)*sqWidth,sqWidth*0.15+1,sqWidth*0.4+1,Math.floor(number/10) % 10)
                ctx.stroke()
            }
            prepareNumber(ctx,(this.x+0.4)*sqWidth,(this.y+0.1)*sqWidth,sqWidth*0.15+1,sqWidth*0.4+1,number % 10)
            ctx.stroke()
        }*/
    }
    drawGlow(ctx){
        
        var sqWidth = 1000/this.parent.boardSize
            
        ctx.fillStyle = "#fff"
        ctx.globalAlpha = 0.5
        ctx.fillRect(this.x*sqWidth,this.y*sqWidth,sqWidth+1,sqWidth+1)
        ctx.globalAlpha = 1
                
    }
    randomLand(ratio){
        this.land = Math.random() < ratio * (1 - 0.05*Math.random())
    }
    addUnit(unit){
        if(this.unit != null){
            alert("there is already an unit")
        }
        this.unit = unit
        if(unit.field != null){
            unit.field.removeUnit(unit)
        }
        unit.field = this
        unit.x = this.x
        unit.y = this.y
        
    }
    removeUnit(unit){
        this.unit = null
        unit.field = null
        unit.x = null
        unit.y = null
    }
}
class Unit{
    constructor(color,size,morale,food){
        this.color = color
        this.size = size

        this.morale = morale
        this.food = food
        
        this.field = null
        this.originalRange = 4
        this.range = 0
        this.restoreRange()
        this.paid = true
        this.moved = false
        
        this.level = 0
    }
    tryFund(way){
        switch(way){
            case -1:
                if(this.level > 0){
                    this.level--
                    this.changeMorale(-4)
                    if(this.morale == 1){
                        this.paid = false
                    }
                }
            break
            case 1:
                var upgradeCost = this.size * 2
                if(this.level < 3/* && this.field.area.money >= upgradeCost*/){
                    this.level++
                    this.changeMorale(4)
                    //this.field.area.money -= upgradeCost
                }
            break
        }
    }
    moneyDemand(){
        return 5 + this.size * 2 * (this.level + 1)
    }
    foodDemand(){
        return this.size
    }
    removeFood(){
        if(this.food > 0){
            this.food--
        } else {
            this.food = 0
        }
    }
    addFood(){
        this.food = 2
    }
    defence(landFrom){
        var factor = 1
        if(this.field.land){
            if(!landFrom.land){
                factor *= 1.5
            }
            if(this.field.cityVillage == 3)
                factor *= 1.4
            if(this.field.fortification)
                factor *= 1.4
            
            factor *= 1 + (this.field.hill - landFrom.hill) * 0.2
        } else {
            return 1
        }
        return factor
    }
    divide(sizeTook){
        this.size -= sizeTook
        var newUnit = new Unit(this.color,sizeTook,this.morale,this.food)
        
        newUnit.range = this.range
        
        return newUnit
    }
    restoreRange(crossCount){
        this.range = this.originalRange
        this.moved = false
        
            var targetMorale = Math.min(5 + crossCount, 9)
            if(this.food == 2 && this.morale < targetMorale)
                this.morale += 1
            if(this.morale > targetMorale)
                this.morale -= 1
    }
    changeMorale(change){
        this.morale = change > 0
            ? Math.min(this.morale + change, 9)
            : Math.max(this.morale + change, 1 + this.level * 2)
    }
    removeRange(range){
        this.range -= range
    }
    draw(ctx, glow, selected, moveCount){
        var sqWidth = 1000/this.field.parent.boardSize
        
        ctx.fillStyle = this.color
        ctx.strokeStyle = /*this.food == 0 ? "#666" : */"#222"
        /*
        if(this.field.parent.truces[this.field.parent.currentPlayer] && this.field.parent.truces[this.field.parent.currentPlayer][this.color] >= 0){
            ctx.strokeStyle = '#4c4'
        }
            
        if(this.field.parent.truces[this.field.parent.currentPlayer] && this.field.parent.truces[this.field.parent.currentPlayer][this.color] == -1){
            ctx.strokeStyle = '#c44'
        }*/
            
        if(glow){
            ctx.strokeStyle = "#ff0"
            ctx.fillStyle = '#00000000'
        }
        if(selected)
            ctx.strokeStyle = "#fff"
        if(this.range <= 0)
            ctx.strokeStyle = "#800"
            
        ctx.fillRect((this.field.x)*sqWidth,(this.field.y-0.1)*sqWidth,sqWidth+1,sqWidth*0.9+1)
        ctx.lineWidth = selected ? 3 : 2
        ctx.strokeRect((this.field.x)*sqWidth,(this.field.y-0.1)*sqWidth,sqWidth+1,sqWidth*0.9+1)
        
        ctx.lineWidth = 1.5
        var size = moveCount
        if(this.size >= 10){
            prepareNumber(ctx,(this.field.x+0.1)*sqWidth,(this.field.y+0.1)*sqWidth,sqWidth*0.15+1,sqWidth*0.4+1,Math.floor(size/10))
            ctx.stroke()
        }
        prepareNumber(ctx,(this.field.x+0.4)*sqWidth,(this.field.y+0.1)*sqWidth,sqWidth*0.15+1,sqWidth*0.4+1,size % 10)
        ctx.stroke()
        
        prepareNumber(ctx,(this.field.x+0.7)*sqWidth,(this.field.y+0.4)*sqWidth,sqWidth*0.2+1,sqWidth*0.3,this.morale)
        ctx.stroke()
        /*
        ctx.fillStyle = "#f00"
        if(this.food == 1){
            ctx.fillStyle = "#ff0"
            prepareDanger(ctx,(this.field.x+0.8)*sqWidth,(this.field.y-0.2)*sqWidth,sqWidth*0.2,sqWidth*0.6)
        }
        if(this.food == 0){
            ctx.fillStyle = "#f00"
            prepareDanger(ctx,(this.field.x+0.8)*sqWidth,(this.field.y-0.2)*sqWidth,sqWidth*0.2,sqWidth*0.6)
        }/*
        if(this.food == 0){
            ctx.fillStyle = "#400"
            prepareDanger(ctx,(this.field.x+0.8)*sqWidth,(this.field.y-0.2)*sqWidth,sqWidth*0.2,sqWidth*0.6)
        }*/
        ctx.strokeStyle = "#850"
        ctx.fillStyle = "#fa0"
        if(this.level >= 1){
            prepareStar(ctx,(this.field.x-0.1)*sqWidth,(this.field.y-0.3)*sqWidth,sqWidth*0.4,sqWidth*0.4)
        }
        if(this.level >= 2){
            prepareStar(ctx,(this.field.x+0.35)*sqWidth,(this.field.y-0.3)*sqWidth,sqWidth*0.4,sqWidth*0.4)
        }
        if(this.level >= 3){
            prepareStar(ctx,(this.field.x+0.7)*sqWidth,(this.field.y-0.3)*sqWidth,sqWidth*0.4,sqWidth*0.4)
        }
        if(this.field.parent.truces[this.field.parent.currentPlayer] && this.color in this.field.parent.truces[this.field.parent.currentPlayer] && this.field.parent.truces[this.field.parent.currentPlayer][this.color] >= 0){
            
            ctx.strokeStyle = "#000"
            ctx.fillStyle = "#0f0"
            
            ctx.fillRect((this.field.x-0.1)*sqWidth,(this.field.y+0.6)*sqWidth,sqWidth*0.5+1,sqWidth*0.4+1)
            ctx.strokeRect((this.field.x-0.1)*sqWidth,(this.field.y+0.6)*sqWidth,sqWidth*0.5+1,sqWidth*0.4+1)

            var truce = this.field.parent.truces[this.field.parent.currentPlayer][this.color]
            prepareNumber(ctx,(this.field.x+0.05)*sqWidth,(this.field.y+0.7)*sqWidth,sqWidth*0.2+1,sqWidth*0.2+1,truce)
            ctx.stroke()
        }
        
        
    }
    rebelIfTired(rebelColor,anyway){
        if(this.food == 0 || !this.paid || anyway){
            this.food = 1
            this.morale = 5
            this.color = rebelColor
            this.level = 0
            return true
        }
        return false
    }
}
class LandWater {
    constructor(lands,parent,number){
        this.lands = lands
        this.parent = parent
        this.number = number
        this.land = null
        this.neighboringAreas = new Set()
        this.borderLands = []
    }
    prepare(){
        this.land = this.lands[0].land
        for(var i in this.lands){
            var land = this.lands[i]
            land.landWaterArea = this
        }
        for(var i in this.lands){
            var land = this.lands[i]

            var neighbors = Object.values(this.parent.getDirectNeighborsWithDiagonals(land.x,land.y)).filter(x=>x != null)
            var isBorderland = false
            for(var i in neighbors){
                var neighbor = neighbors[i]
                if(neighbor.landWaterArea != null && neighbor.landWaterArea != this){
                    this.neighboringAreas.add(neighbor.landWaterArea)
                    neighbor.landWaterArea.neighboringAreas.add(this)
                }
                if(neighbor.landWaterArea != this && !isBorderland){
                    isBorderland = true
                    this.borderLands.push(land)
                }
                    
            }
        }
    }
}
class Model {
    constructor(){
        this.boardSize = 30
        this.landWaterRatio = 0.48
        this.landDistanceRatio = -0.05
        this.sizeOfLands = 3
        this.smoothingOfLand = 2
        
        this.hillSmoothness = 1
        this.plainIncidence = 1.8
        
        this.cityRatio = 0.05
        this.portRatio = 0.1
        this.villageRatio = 0.7
        this.mineRatio = 0.1
        this.holyRatio = 0.005
        
        this.moneyForSoldier = 5
        this.startMoneyForArea = 50
        
        this.board = []
        this.allLands = []
        this.units = []
        this.colors = []
        
        this.phase = 0
        
        this.selectedUnit = null
        this.selectedUnitMoveCount = 0
        
        this.selectedUnitLegalMoves = []
        
        this.areas = []
        this.landWaterAreas = []
        this.addingSize = 0
        this.updowngradeWay = null
        
        
        this.truces = {}
        this.proposerTruceLength = 5
    }
    copyModel(){
        var state = this.saveState()
        
        var newModel = new Model()
        var boardData = this.copyPlainBoard(newModel)
        newModel.board = boardData.board
        newModel.allLands = boardData.fieldSet
        
        newModel.restoreState(state,newModel)
        return newModel
    }
    copyPlainBoard(model){
        var newBoard = []
        var newFieldSet = []
        for(var i = 0;i<this.boardSize;i++){
            newBoard.push([])
            for(var j = 0;j<this.boardSize;j++){
                var field = this.board[i][j]
                var newField = new Square(i,j,model)
                newBoard[i].push(newField)
                newFieldSet.push(newField)
                
                newField.land = field.land
                newField.hill = field.hill
                newField.cityVillage = field.cityVillage
                newField.unit = null
            }
        }
        return {board: newBoard, fieldSet: newFieldSet}
    }
    
    saveState(){
        return {
            phase:this.phase,
            currentPlayer:this.currentPlayer,
            temporaryPlayer:this.temporaryPlayer,
            selectedUnit: this.selectedUnit ? {x: this.selectedUnit.field.x, y: this.selectedUnit.field.y } : null,
            selectedUnitMoveCount:this.selectedUnitMoveCount,
            selectedUnitLegalMoves:this.selectedUnitLegalMoves.map(a=>new Object( {x:a.x, y:a.y, distance: a.distance, lastMove: a.lastMove, stopHere:a.stopHere})),
            addingSize:this.addingSize,
            updowngradeWay:this.updowngradeWay,
            board: this.saveBoard(),
            areas: this.saveAreas(),
            colors: this.colors.slice(),
            truces: Object.assign(this.truces)
        }
    }
    saveBoard(){
        var newBoard = []
        for(var i = 0;i<this.boardSize;i++){
            newBoard[i] = []
            for(var j = 0;j<this.boardSize;j++){
                var field = this.board[i][j]
                newBoard[i][j] = {
                    x:i,
                    y:j,
                    color:field.color,
                    unit:this.saveUnit(field.unit),
                    fortification:field.fortification
                }
            }
        }
        return newBoard
    }
    saveUnit(unit){
        if(unit == null)
            return null
        return {
            color:unit.color,
            size:unit.size,
            morale:unit.morale,
            food:unit.food,
            range:unit.range,
            paid:unit.paid,
            moved:unit.moved,
            level:unit.level
        }
    }
    restoreBoard(board){
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                if(this.board[i][j].unit)
                    this.board[i][j].removeUnit(this.board[i][j].unit)
                this.board[i][j].color = board[i][j].color
                this.board[i][j].area = null
                this.board[i][j].fortification = fortification
                var unit = board[i][j].unit
                if(unit != null){
                    this.restoreUnit(i,j,unit)
                }
            }
        }
    }
    restoreUnit(x,y,unitData){
        var newUnit = new Unit(unitData.color,unitData.size,unitData.morale,unitData.food)
        
        newUnit.range = unitData.range
        newUnit.paid = unitData.paid
        newUnit.moved = unitData.moved
        newUnit.level = unitData.level
        
        this.board[x][y].addUnit(newUnit)
        
    }
    saveAreas(){
        var newAreas = []
        for(var i in this.areas){
            var area = this.areas[i]
            newAreas.push({
                color:area.color,
                money:area.money,
                people:area.people,
                food:area.food,
                
                villages:area.villages,
                cities:area.cities,
                mines:area.mines,
                crosses:area.crosses,
                
                fields:area.fields.map( a=>new Object({ x:a.x, y:a.y })),
                
                number:area.number
            })
        }
        return newAreas
    }
    restoreState(state,model){
        this.phase = state.phase
        this.currentPlayer = state.currentPlayer
        this.temporaryPlayer = state.temporaryPlayer
        
            this.restoreBoard(state.board)
            this.restoreAreas(state.areas,model)
            
        this.selectedUnit = state.selectedUnit ? this.board[state.selectedUnit.x][state.selectedUnit.y].unit : null
        this.selectedUnitMoveCount = state.selectedUnitMoveCount
        this.selectedUnitLegalMoves = state.selectedUnitLegalMoves.map(a=>new Object( {x:a.x, y:a.y, distance: a.distance, lastMove: a.lastMove, stopHere:a.stopHere}))
        this.addingSize = state.addingSize
        this.updowngradeWay = state.updowngradeWay
        this.colors = state.colors.slice()
        this.truces = Object.assign(state.truces)
    }
    restoreAreas(areas,model){
        this.areas = []
        
        for(var i in areas){
            var area = areas[i]

            var newArea = new Area(area.color,model)
            
            newArea.money = area.money
            newArea.people = area.people
            
            newArea.food = area.food
            
            newArea.villages = area.villages
            newArea.cities = area.cities
            newArea.mines = area.mines
            newArea.crosses = area.crosses
            
            newArea.fields = area.fields.map(a=>this.board[a.x][a.y])
            for(var i in newArea.fields){
                newArea.fields[i].area = newArea
            }
            
            newArea.number = area.number
            
            this.areas.push(newArea)
        }
    }
    
    prepareBoard(){
        
        this.board = []
        this.allLands = []
        for(var i = 0;i<this.boardSize;i++){
            this.board[i] = []
            for(var j = 0;j<this.boardSize;j++){
                this.board[i][j] = new Square(i,j,this)
                this.allLands.push(this.board[i][j])
                var ratio = this.landWaterRatio-Math.max(Math.abs(1/2-i/this.boardSize),Math.abs(1/2-j/this.boardSize)*2)*this.landDistanceRatio
                this.board[i][j].randomLand(ratio)
            }
        }
        
        this.smoothBoard(this.sizeOfLands)
        this.smoothBoard(this.smoothingOfLand)
        this.fillHills()
        this.prepareTowns()
        this.prepareUnits()
    }
    fillHills(){
        var newhill = []
        for(var i = 0;i<this.boardSize;i++){
        
            newhill[i] = []
            for(var j = 0;j<this.boardSize;j++){
                if(this.board[i][j].land){
                    this.board[i][j].hill = Math.floor(Math.random()*6)
                } else {
                    this.board[i][j].hill = -1
                }
                newhill[i][j] = this.board[i][j].hill
            }
        }
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                if(Math.random() < this.plainIncidence/this.boardSize){
                    var rowniny = new Set()
                    var repeat = Math.ceil(Math.random()*this.sizeOfLands*2)
                    for(var z = 0;z<repeat;z++){
                        var x_ = Math.floor((1-Math.random()*2)*this.sizeOfLands), y_ = Math.floor((1-Math.random()*2)*this.sizeOfLands)
                        var rownina = this.getNeighbors(i - x_,j - y_,this.hillSmoothness).filter(x=>x.land == true)
                        for(var k in rownina){
                            rowniny.add(rownina[k])
                        }
                        if(i - x_ in this.board && j - y_ in this.board[i - x_])
                            rowniny.add(this.board[i - x_][j - y_])
                    }
                    rowniny = Array.from(rowniny)
                    for(var k in rowniny){
                        rowniny[k].hill = 0
                        newhill[rowniny[k].x][rowniny[k].y] = 0
                    }
                    this.board[i][j].hill = 0
                }
            }
        }
        
        for(var k = 0;k<4;k++){
            for(var i = 0;i<this.boardSize;i++){
                for(var j = 0;j<this.boardSize;j++){
                    if(this.board[i][j].land){
                        var bhil = this.board[i][j].hill
                        var shore = this.getNeighbors(i,j,2).filter(x=>!x.land).length > 0
                        if(shore){
                            newhill[i][j] = 0
                        } else {
                            var nei = this.getNeighbors(i,j,this.hillSmoothness)
                            if(nei.filter(x=>x.hill < bhil).length > nei.length*Math.min(0.5))
                                newhill[i][j]--
                            else if(nei.filter(x=>x.hill > bhil).length > nei.length*Math.min(0.5))
                                newhill[i][j]++
                        }

                    }
                }
            }
            for(var i = 0;i<this.boardSize;i++){
                for(var j = 0;j<this.boardSize;j++){
                    this.board[i][j].hill = newhill[i][j]
                    
                }
            }
        }
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                this.board[i][j].hill = Math.min(this.board[i][j].hill,6)
                if(!this.board[i][j].land){
                    this.board[i][j].hill = 0
                    this.board[i][j].cityVillage = 0
                }
            }
        }
    }
    prepareTowns(){
    
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                var shore = this.getNeighbors(i,j,1).filter(x=>!x.land).length > 0
                if(Math.random() < this.villageRatio / (this.board[i][j].hill+1))
                    this.board[i][j].cityVillage = 1
                if(Math.random() < this.mineRatio * (1 - 1/(this.board[i][j].hill+1)))
                    this.board[i][j].cityVillage = 2
                if(Math.random() < this.holyRatio)
                    this.board[i][j].cityVillage = 4
                if(shore){
                    if(Math.random() < this.portRatio)
                        this.board[i][j].cityVillage = 3
                } else {
                    if(Math.random() < this.cityRatio * (7-this.board[i][j].hill) / 7)
                        this.board[i][j].cityVillage = 3
                }
            }
        }
        
        var n = 0
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                var land = this.board[i][j]
                if(land.landWaterArea == null){
                    var newLands = this.getAreaPartsWithTheSameLandWater(i,j)
                    var newLandwater = new LandWater(newLands,this,n)
                    newLandwater.prepare()
                    this.landWaterAreas.push(newLandwater)
                    n++
                }
            }
        }
        for(var i in this.landWaterAreas){
            var landWaterArea = this.landWaterAreas[i]
            console.log(landWaterArea.land)
            if(landWaterArea.land){
                var seas = Array.from(landWaterArea.neighboringAreas)
                for(var j in seas){
                    var sea = seas[j]
                    var possibleLocationsOfPort = landWaterArea.borderLands.filter(a=>Object.values(this.getDirectNeighborsWithDiagonals(a.x,a.y)).filter(b=>b != null && b.landWaterArea == sea).length > 0)
                    var randomLand = possibleLocationsOfPort[Math.floor(Math.random()*possibleLocationsOfPort.length)]

                    randomLand.cityVillage = 3
                }
            }
        }
        
    }
    smoothBoard(neighbors){
        var tempBoard = []
        for(var i = 0;i<this.boardSize;i++){
            tempBoard[i] = []
            for(var j = 0;j<this.boardSize;j++){
                var nei = this.getNeighbors(i,j,neighbors)
                tempBoard[i][j] = nei.filter(x=>x.land).length*2 >= nei.length
            }
        }
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                this.board[i][j].land = tempBoard[i][j]
            }
        }
    }
    getDirectNeighbors(x,y){
        return {
            left: x > 0 ? this.board[x-1][y] : null,
            right: x < this.boardSize-1 ? this.board[x+1][y] : null,
            top: y > 0 ? this.board[x][y-1] : null,
            bottom: y < this.boardSize-1 ? this.board[x][y+1] : null,
        }
    }
    getDirectNeighborsWithDiagonals(x,y){
        return {
            left: x > 0 ? this.board[x-1][y] : null,
            right: x < this.boardSize-1 ? this.board[x+1][y] : null,
            top: y > 0 ? this.board[x][y-1] : null,
            bottom: y < this.boardSize-1 ? this.board[x][y+1] : null,
            lefttop: x > 0 && y > 0 ? this.board[x-1][y-1] : null,
            leftbottom: x > 0 && y < this.boardSize-1 ? this.board[x-1][y+1] : null,
            righttop: x < this.boardSize-1 && y > 0 ? this.board[x+1][y-1] : null,
            rightbottom: x < this.boardSize-1 && y < this.boardSize-1 ? this.board[x+1][y+1] : null,
        }
    }
    getNeighbors(x,y,d){
        var neighbors = []
        for(var i = x-d;i<=x+d;i++){
            for(var j = y-d;j<=y+d;j++){
                if((i!=x || j!=y) && i>=0 && i<this.boardSize && j>=0 && j<this.boardSize && Math.pow(i-x,2)+Math.pow(j-y,2) <= d*d){
                    neighbors.push(this.board[i][j])
                }
            }
        }
        return neighbors
    }
    getLandNeighbors(x,y,d,checkIfSomeoneHere){
        var search = [this.board[x][y]]
        var newsearch = []
        var found = search.slice()  //copy
        for(var i = 0;i<d;i++){
            for(var j in search){
                var b = search[j]
                var ne = this.getNeighbors(b.x,b.y,1).filter(z=>z.land && found.indexOf(z) == -1 && (checkIfSomeoneHere != true || z.people.length == 0))
                newsearch = newsearch.concat(ne)
                found = found.concat(ne)
            }
            search = newsearch
            newsearch = []
        }
        return found
    }
    prepareUnits(){
        this.colors = []
        this.truces = {}
    
        var cities = this.allLands.filter(x => x.land == true && x.cityVillage == 3)
        cities = cities.map(value => ({ value, sort: Math.random() }))
            .sort((a, b) => a.sort - b.sort)
            .map(({ value }) => value)
        cities = cities.slice(0,Math.floor(cities.length/2.5))
        
        for(var i in cities){
            var city = cities[i]
            var color = randomColor()
            var newUnit = new Unit(color,50,5,2)
            if(this.colors.indexOf(color) == -1){
                this.colors.push(color)
                this.truces[color] = {}
            }
            this.placeUnit(city.x,city.y,newUnit)
        }
        for(var i in this.areas){
            this.areas[i].money += 50
        }
    }
    announceCapture(field, unit, previousColor, color){
        var ownMoraleGain, moraleGain
        switch(field.cityVillage){
            case 1:
            case 2:
                ownMoraleGain = 1
                moraleGain = 0
            break
            case 3:
                ownMoraleGain = 2
                moraleGain = 1
            break
            case 4:
                ownMoraleGain = 4
                moraleGain = 2
            break
        }
        if(moraleGain > 0){
            unit.changeMorale(ownMoraleGain)
            this.allLands.filter(x => x != field && x.unit != null && x.color == color).map(x=>x.unit).forEach(x=>x.changeMorale(moraleGain))
            if(previousColor != color)
                this.allLands.filter(x => x.unit != null && x.color == previousColor).map(x=>x.unit).forEach(x=>x.changeMorale(-moraleGain))
        }
        
    }
    colorTrack(x,y,unit){
        this.board[x][y].color = unit.color
        
        var neighbors = Object.values(this.getDirectNeighborsWithDiagonals(x,y))
        
        for(var i in neighbors){

            if(neighbors[i] != null){
                if(unit.color != null && neighbors[i].color in this.truces[unit.color] && this.truces[unit.color][neighbors[i].color] >= 0)
                    continue
                if(neighbors[i].fortification && neighbors[i].fortificationColor != unit.color)
                    continue
                
                this.tryColor(neighbors[i],unit.color)
            }
        }
    }
    placeUnit(x,y,unit,colorTrack,addMorale){
        if(colorTrack == undefined)
            colorTrack = true
        if(addMorale == undefined)
            addMorale = false
        this.board[x][y].addUnit(unit)
        
        if(colorTrack){
        
            var previousColor = this.board[x][y].color
            this.colorTrack(x,y,unit)
            
            if(addMorale && previousColor != unit.color){
                this.announceCapture(this.board[x][y],unit,previousColor,unit.color)
            }
        }
        
        if(this.units.indexOf(unit) == -1)
            this.units.push(unit)
    }
    tryColor(land,color){
        if(!land.land)
            return
        if([2,3,4].indexOf(land.cityVillage) > -1)
            return
        if(Object.values(this.getDirectNeighbors(land.x,land.y)).concat([land]).filter(x=>x != null && (x.unit && x.unit.color != color)).length > 0)
            return
        land.color = color
    }
    nextTurn(dontOrganize){
        var crossCount = this.allLands.filter(x=>x.color == this.currentPlayer && x.land && x.cityVillage == 4).length
        this.allLands.filter(x=>x.unit != null && x.color == this.currentPlayer).map(x=>x.unit).forEach(x=>x.restoreRange(crossCount))
        this.allLands.filter(x=>x.unit != null && x.fortification && x.fortificationColor != x.color).forEach(x => x.fortification = false)
        
        if(!dontOrganize){
            this.organizeAreas()
            
            for(var i in this.areas){
                var area = this.areas[i]
                if(area.color == this.currentPlayer){
                    area.redistribute()
                }
            }
            
        }
        var newColors = []
        for(var i in this.colors){
            var color = this.colors[i]
            
            var units = this.allLands.filter(x=>x.unit && x.unit.color == color).map(x=>x.unit)
            
            if(color == this.currentPlayer){
                var rebelColor = randomColor()
                var added = false
                for(var i in units){
                    var unit = units[i]
                    if(unit.rebelIfTired(rebelColor)){
                        this.truces[rebelColor] = {}

                        var field = unit.field
                        field.removeUnit(unit)
                        this.placeUnit(field.x,field.y,unit)
                        added = true
                    }
                }
                if(added && this.colors.indexOf(rebelColor) == -1 && newColors.indexOf(rebelColor) == -1){
                    newColors.push(rebelColor)
                    this.organizeAreas()
                    for(var i in this.areas){
                        var area = this.areas[i]
                        if(area.color == rebelColor){
                            area.redistribute()
                        }
                    }

                }
            }
        }
        
        var ix = this.colors.indexOf(this.currentPlayer)
        var oix = ix
        this.currentPlayer = ix+1 >= this.colors.length ? this.colors[0] : this.colors[ix+1]
        
        if(!dontOrganize){
            this.colors = this.colors.slice(0,oix).concat(newColors).concat(this.colors.slice(oix))
        }
        
        if(this.allLands.filter(x=>x.color == this.currentPlayer && x.land).length == 0){
            this.nextTurn(true)
        } else {
            for(var player in this.truces[this.currentPlayer]){
                if(this.truces[this.currentPlayer][player] > 0){
                    this.truces[this.currentPlayer][player]--
                } else {
                    delete this.truces[this.currentPlayer][player]
                }
            }
            console.log(this.legalMoves())
        }
    }
    
    
    startGame(color){
        if(this.phase == 0){
            this.phase = 1
            this.color = color
            this.currentPlayer = this.colors[0]
            this.temporaryPlayer = null
            
            this.organizeAreas()
            for(var i in this.areas){
                this.areas[i].redistribute()
                //this.areas[i].money = this.startMoneyForArea
            }
        }
    }
    multiplyMoveCount(size, moveCount){
        return Math.ceil(size * moveCount)
    }
    
    lateness(landFrom,landTo,unit,unitLand){
        var MAX = unit.originalRange //makes unit stop
        var diagonalFafctor = Math.abs(landFrom.x - landTo.x) + Math.abs(landFrom.y - landTo.y) >= 2 ? 1.5 : 1
        if(landTo.unit != null && landTo.unit.color != unit.color)
            return MAX
        if(landTo.cityVillage == 3){
            return MAX
        }
        if(!unitLand.land){
            if(!landFrom.land && landTo.land)
                return MAX
        } else {
            if(landTo.fortification && landTo.fortificationColor != unit.color)
                return MAX
                
            if(landFrom.land && !landTo.land && !(unitLand == landFrom && landFrom.cityVillage == 3)){
                if(unitLand != landFrom)
                    return null
                else
                    return MAX
            }
            if(landTo.hill >= 1)
                return (1 + landTo.hill/3) * diagonalFafctor
        }
        return 1 * diagonalFafctor
    }
        
    getUnitLegalMoves(x,y){
        return this.getUnitLegalMovesForMoreTurns(x,y,1)
    }
    getUnitLegalMovesForMoreTurns(x,y,turns){
        var land = this.board[x][y]
        var legalMoves = [{x: x,y: y,distance: 0, lastMove: null, stopHere: false, turn:0, initialLand: land}]
        var legalMovesAdded = new Set([x+'#'+y])
        var legalMovesAddedBoard = {}
        legalMovesAddedBoard[x+'#'+y] = legalMoves[0]
        var searchedLegalMoves = legalMoves.slice()
        var nextLegalMoves = []
        var turnLegalMoves = []
        for(var t = 0;t<turns;t++){
            var range = t == 0 ? land.unit.range : land.unit.originalRange
            for(var i = 0;i<range;i++){
                for(var j in searchedLegalMoves){
                    var move = searchedLegalMoves[j]
                    var landFrom = this.board[move.x][move.y]
                    if(landFrom != move.initialLand && (move.distance >= range || move.stopHere)){
                        continue
                    }
                        
                    var neighbors = Object.values(this.getDirectNeighborsWithDiagonals(move.x, move.y)).filter(a=>a != null)
                    
                    var stopHere = false
                    //if(/*landFrom != land && */Object.values(this.getDirectNeighbors(move.x, move.y)).filter(x=>x != null && x.unit && x.unit.color != land.unit.color).length > 0)
                    //    stopHere = true
                    
                    for(var k in neighbors){
                        var neighbor = neighbors[k]
                        var lateness = this.lateness(landFrom,neighbor,land.unit,move.initialLand)
                        if(lateness == null){
                            continue
                        }
                        if(land.color != null && neighbor.color in this.truces[land.color] && this.truces[land.color][neighbor.color] >= 0)
                            continue
                        //if(stopHere && !neighbor.unit)
                        //    continue
                            
                        if(!(legalMovesAdded.has(neighbor.x+'#'+neighbor.y))){
                            var newMove = {x:neighbor.x, y:neighbor.y, distance: move.distance + lateness, lastMove: move, stopHere:stopHere, turn:t, initialLand: move.initialLand}
                            legalMoves.push(newMove)
                            legalMovesAdded.add(newMove.x+'#'+newMove.y)
                            legalMovesAddedBoard[newMove.x+'#'+newMove.y] = newMove
                            nextLegalMoves.push(newMove)
                            turnLegalMoves.push(newMove)
                            //this.board[newMove.x][newMove.y].debug = t
                        } else {
                            var existingMove = legalMovesAddedBoard[neighbor.x+'#'+neighbor.y]
                            if((existingMove.distance > move.distance + lateness) && existingMove.turn == t){
                                existingMove.distance = move.distance + lateness
                                existingMove.lastMove = move
                                existingMove.initialLand = move.initialLand
                                //this.board[existingMove.x][existingMove.y].debug = t

                            }
                        }
                    }
                }
                searchedLegalMoves = nextLegalMoves
                nextLegalMoves = []
            }
            if(t < turns -1){
                legalMoves.forEach(x => {x.distance = 0; x.initialLand = this.board[x.x][x.y];x.stopHere = false})
                
                searchedLegalMoves = turnLegalMoves.slice()//legalMoves.filter(a => Object.values(this.getDirectNeighborsWithDiagonals(a.x, a.y)).filter(x => x != null && !legalMovesAdded.has(x.x+'#'+x.y)).length > 0)
                turnLegalMoves = []
                console.log(searchedLegalMoves.length)
                //var neighboring = legalMoves.filter(a => a != null )
            }
        }
        var set = Array.from(new Set(legalMoves.map(x => [x.initialLand, x.turn]).map(x => x[0].x + '#' + x[0].y+'#'+x[1])))
        for(var i in set){
            var s = set[i].split('#')
            //console.log(s)
            //this.board[Number(s[0])][Number(s[1])].debug = s[2]
        }
        return legalMoves
    }
    selectUnit(x,y,part){
        if(this.phase == 1 && this.board[x][y].unit){
            var unit = this.board[x][y].unit
            if(unit.color == this.currentPlayer/* && unit.food > 0*/){
                this.selectedUnit = unit
                this.selectedUnitMoveCount = part
                this.selectedUnitLegalMoves = this.getUnitLegalMoves(x,y)
            }
        }
    }
    
    battle(unit1,unit2,fieldFrom){
        var defence = unit2.defence(fieldFrom)
        
        var value1 = unit1.size * unit1.morale
        var value2 = unit2.size * unit2.morale * defence
        
        if(value2 > value1){
            var rest = unit2.size * Math.sqrt(1 - value1 * value1 / value2 / value2)
            unit1.size = 0
            unit2.size = Math.ceil(rest)
            unit2.changeMorale(2)
            fieldFrom.removeUnit(unit1)
        } else {
            var rest = unit1.size * Math.sqrt(1 - value2 * value2 / value1 / value1)
            unit1.size = Math.ceil(rest)
            unit2.size = 0
            unit1.changeMorale(2)
            unit2.field.removeUnit(unit2)
            
        }
    }
    merge(unit1,unit2,fieldFrom){
        var value1 = unit1.size
        var value2 = unit2.size
        
        var newSize = Math.min(99, value1 + value2)
        var leftSize = Math.max(0, value1 + value2 - 99)
        
        unit2.size = newSize
        unit2.morale = Math.round((unit1.morale * value1 + unit2.morale * value2) / (value1 + value2))
        unit2.food = Math.floor((unit1.food * value1 + unit2.food * value2) / (value1 + value2))
        unit1.size = leftSize
        unit2.level = value1 > value2 ? unit1.level : unit2.level
        unit2.range = Math.min(unit1.range,unit2.range)
        if(fieldFrom != undefined && leftSize == 0)
            fieldFrom.removeUnit(unit1)
    }
    moveUnit(x1,y1,x2,y2,moveCount){
        if(this.board[x1][y1].unit && this.board[x1][y1].unit.color == this.currentPlayer){
            var legalMoves = this.getUnitLegalMoves(x1,y1)
            var foundMoves = legalMoves.filter(a=>a.x == x2 && a.y == y2)
            if(foundMoves.length >= 1){
                var distance = foundMoves[0].distance
                
                var unit1 = this.board[x1][y1].unit
                unit1.moved = true
                var unit2 = this.board[x2][y2].unit ? this.board[x2][y2].unit : null
                var maxToPlace = (unit2 && unit2.color == unit1.color) ? 99 - unit2.size : 99
                var toLeave = unit1.size - Math.min( this.multiplyMoveCount(unit1.size,moveCount), maxToPlace )
                
                var unitLeft
                this.board[x1][y1].removeUnit(unit1)
                if(toLeave > 0){
                    unitLeft = unit1.divide(toLeave)
                }
                
                unit1.removeRange(distance)
                if(unit2){
                    if(unit2.color != unit1.color){
                        this.battle(unit1,unit2,this.board[x1][y1])
                    } else {
                        this.merge(unit1,unit2,this.board[x1][y1])
                    }
                }
                
                var lastMove = foundMoves[0].lastMove
                this.colorTrack(lastMove.x,lastMove.y,unit1)
                for(var i = 0;i<unit1.originalRange && lastMove != null;i++){
                    this.colorTrack(lastMove.x,lastMove.y,unit1)

                    lastMove = lastMove.lastMove
                }
                if(toLeave > 0){
                    this.placeUnit(x1,y1,unitLeft)
                }
                
                if(unit1.size > 0){
                    this.placeUnit(x2,y2,unit1,true,true)
                }
                this.deselectUnit()
                
                this.organizeAreas()
            }
        }
    }

    deselectUnit(){
        this.selectedUnit = null
        this.selectedUnitMoveCount = 0
        
        
        this.selectedUnitLegalMoves = []
    }
    
    organizeAreas(){
        for(var i in this.areas){
            var area = this.areas[i]
            area.shrink()
        }
        for(var i in this.areas){
            var area = this.areas[i]
            area.tryGiveMoney()
            var areaSize = area.fields.length
            var newAreas = area.divide()
            for(var j in newAreas){
                this.addArea(newAreas[j])
                newAreas[j].shrinkMorale(areaSize)
            }
            if(newAreas.length > 0)
                area.shrinkMorale(areaSize)
        }
        for(var i = 0;i<this.boardSize;i++){
            for(var j = 0;j<this.boardSize;j++){
                var field = this.board[i][j]
                
                if(field.land && field.color != null && field.area == null){
                    var area = new Area(field.color,this)
                    this.fillNewArea(area,i,j)
                    area.setFields()
                    this.addArea(area)
                }
            }
        }
        /*
        for(var i in this.areas){
            var area = this.areas[i]
            
            //if(area.fields.length > 0)
            //    area.tryMerge()
        }*/
        this.areas = this.areas.filter(x=>x.fields.length > 0)
    }
    addArea(area){
        this.areas.push(area)
        area.number = this.areas.length == 0 ? 1 : this.areas.map(x => x.number).reduce((a,b)=>Math.max(a,b),0)+1
    }
    fillNewArea(area,x,y){
        var areaPartsWithTheSameColor = this.getAreaPartsWithTheSameColor(area.color,x,y).filter(a=>a.land)
        area.fields = areaPartsWithTheSameColor
    }
    getAreaPartsWithTheSameColor(color,x,y){
        var land = this.board[x][y]
        var lands = [land]
        var searchedLands = lands.slice()
        var nextLands = []
        for(var i = 0;i<this.boardSize*this.boardSize && searchedLands.length > 0;i++){
            for(var j in searchedLands){
                var lookedUpLand = searchedLands[j]
                var landFrom = this.board[lookedUpLand.x][lookedUpLand.y]

                var neighbors = Object.values(this.getDirectNeighborsWithDiagonals(lookedUpLand.x, lookedUpLand.y)).filter(a=>a != null && a.area == null && (a.color == color || (!a.land && (!a.unit || a.unit.color == color))))
                
                for(var k in neighbors){
                    var neighbor = neighbors[k]
                        
                    if(lands.filter(a=>a.x == neighbor.x && a.y == neighbor.y).length == 0){
                        var newLand = this.board[neighbor.x][neighbor.y]
                        lands.push(newLand)
                        nextLands.push(newLand)
                    }
                }
            }
            searchedLands = nextLands
            nextLands = []
        }
        return lands
    }
    
    getAreaPartsWithTheSameLandWater(x,y,straitBlockades){
        var land = this.board[x][y]
        var lands = [land]
        var landWater = land.land
        var searchedLands = lands.slice()
        var nextLands = []
        for(var i = 0;i<this.boardSize*this.boardSize && searchedLands.length > 0;i++){
            for(var j in searchedLands){
                var lookedUpLand = searchedLands[j]
                var landFrom = this.board[lookedUpLand.x][lookedUpLand.y]

                var neighbors = Object.values(this.getDirectNeighborsWithDiagonals(lookedUpLand.x, lookedUpLand.y)).filter(a=>a != null && a.land == landWater)
                
                for(var k in neighbors){
                    var neighbor = neighbors[k]
                        
                    if(lands.filter(a=>a.x == neighbor.x && a.y == neighbor.y).length == 0 && (!straitBlockades || this.board[neighbor.x][neighbor.y].unit != landFrom.color)){
                        var newLand = this.board[neighbor.x][neighbor.y]
                        lands.push(newLand)
                        nextLands.push(newLand)
                    }
                }
            }
            searchedLands = nextLands
            nextLands = []
        }
        return lands
    }
    
    startAdding(size){
        this.deselectUnit()
        this.phase = 2
        this.addingSize = size
        
        this.organizeAreas()
    }
    backToPlaying(){
        this.temporaryPlayer = null
        this.phase = 1
    }
    updowngrade(way){
        this.deselectUnit()
        this.phase = 3
        this.updowngradeWay = way
    }
    startTrucing(){
        this.phase = 4
    }
    changeProposerTruceLength(n){
        this.proposerTruceLength = n
    }
    startFortifying(){
        this.phase = 6
    }
    acceptTruce(){
        this.phase = 1
        this.truces[this.currentPlayer][this.temporaryPlayer] = this.proposerTruceLength
        this.truces[this.temporaryPlayer][this.currentPlayer] = this.proposerTruceLength
    }
    rejectTruce(){
        this.phase = 1
        this.truces[this.currentPlayer][this.temporaryPlayer] = -1
    }
    tryPlaceUnit(x,y,addingSize){
        var land = this.board[x][y]
        var newAddingSize = addingSize
        if(land.land && land.color == this.currentPlayer){
            var area = land.area
            if(Math.min(area.availableNewTroops(), area.people) == 0)
                return
            if(Math.min(area.availableNewTroops(), area.people) < newAddingSize){
                newAddingSize = Math.min(area.availableNewTroops(), area.people)
            }
            if(land.unit == null){
                var newUnit = new Unit(land.color,newAddingSize,5,0)
                newUnit.range = 0
                this.placeUnit(x,y,newUnit,false)
            } else {
                if(newAddingSize + land.unit.size > 99)
                    newAddingSize = 99 - land.unit.size
                var newUnit = new Unit(land.unit.color,newAddingSize,5,0)
                newUnit.range = 0
                this.merge(newUnit, land.unit)
            }
            area.money -= newAddingSize * this.moneyForSoldier
            area.people -= newAddingSize
        }
    }
    tryUpDowngradeUnit(x,y,updowngradeWay){
        var land = this.board[x][y]
        if(land.land && land.color == this.currentPlayer && land.unit && land.unit.color == this.currentPlayer){
            land.unit.tryFund(updowngradeWay)
        }
    }
    tryTruce(x,y,proposerTruceLength){
        var land = this.board[x][y]
        
        if(land.land && land.color != this.currentPlayer && land.color != undefined && !(land.color in this.truces[this.currentPlayer])){
            this.proposerTruceLength = proposerTruceLength
            this.phase = 5
            this.temporaryPlayer = land.color
        }
    }
    tryFortify(x,y){
        var land = this.board[x][y]
        var fortificationPrice = 50
        if(land.land && land.cityVillage != 3 && land.color == this.currentPlayer && !land.fortification){
            if(land.area.money >= fortificationPrice){
                land.area.money -= fortificationPrice
                land.fortification = true
                land.fortificationColor = this.currentPlayer
            }
        }
    }
    
    
    
    //move (x1,y1,x2,y2,part)
    //fund (x,y,plusminus)
    //recruit (x,y,size)
    //fortify (x,y)
    //truce (color,turns)
    legalMoves(){
        return this.possibleUnitMoves()
            .concat(this.possibleUnitFunding())
            .concat(this.possibleRecruitments())
    }
    makeMove(move){
        
    }
    
    possibleUnitMoves(){
        var units = this.allLands.filter(x=>x.unit != null && x.unit.color == this.currentPlayer).map(x=>x.unit)
        var legalMoves = []
        for(var i in units){
            var unit = units[i]
            legalMoves.push({
                type:'move',
                x:unit.x,
                y:unit.y,
                destinations:this.getUnitLegalMoves(unit.x,unit.y).map(a=>new Object({x:a.x, y:a.y}))
            })
        }
        return legalMoves
    }
    possibleUnitFunding(){
        var units = this.allLands.filter(x=>x.unit != null && x.unit.color == this.currentPlayer).map(x=>x.unit)
        var legalMoves = []
        for(var i in units){
            var unit = units[i]
            var plusminus = [-1,1]
            if(unit.level == 0)
                plusminus = [1]
            if(unit.level == 3)
                plusminus = [-1]
            legalMoves.push({
                type:'fund',
                x:unit.x,
                y:unit.y,
                plusminus:plusminus
            })
        }
        return legalMoves
    }
    possibleRecruitments(){
        var lands = this.allLands.filter(x=>x.color == this.currentPlayer).filter(x=>x.unit == null || x.unit.size < 99)
        var legalMoves = []
        for(var i in lands){
            var land = lands[i]
            var sizes = [5]
            if(land.unit == null || land.unit.size < 95)
                sizes.push(10)
            if(land.unit == null || land.unit.size < 90)
                sizes.push(50)
            if(land.unit == null || land.unit.size < 50)
                sizes.push(99)
            legalMoves.push({
                type:'recruit',
                x:land.x,
                y:land.y,
                sizes:sizes
            })
        }
        return legalMoves
    }
    
}
class Area{
    constructor(color,model){
        this.color = color
        this.model = model
        this.money = 0
        this.people = 0
        
        this.food = 0
        
        this.villages = 0
        this.cities = 0
        this.mines = 0
        this.crosses = 0
        
        this.fields = []
        
        this.number = null
    }
    shrinkMorale(originalFields){
        var moraleChange = 0
        if(originalFields > this.fields.length * 2)
            moraleChange = -2
        else if(originalFields > this.fields.length)
            moraleChange = -1
            
        this.fields.filter(x => x.unit != null && x.color == this.color).map(x=>x.unit).forEach(x=>x.changeMorale(moraleChange))

            
    }
    availableNewTroops(){
        return Math.floor(this.money / this.model.moneyForSoldier)
    }
    peopleSupply(){
        return this.villages * 1 + this.cities * 10 + this.mines * 1
    }
    foodSupply(){
        return this.villages * 10 + this.cities * 1
    }
    moneySupply(){
        return this.villages * 10 + this.cities * 100 + this.mines * 100
    }
    
    foodDemand(){
        return this.fields.filter(x=>x.unit).map(x=>x.unit.foodDemand()).reduce((a,b)=>a+b,0)
    }
    moneyDemand(){
        return this.fields.filter(x=>x.unit).map(x=>x.unit.moneyDemand()).reduce((a,b)=>a+b,0)
    }
    shrink(){
        for(var i in this.fields){
            var field = this.fields[i]
            
            if(field.area == this)
                field.area = null
        }
        this.fields = this.fields.filter(x=>x.color == this.color)
    }
    divide(){
        this.fields = this.fields.filter(x=>x.area == null)
        if(this.fields.length == 0)
            return []
            
        var newAreas = []
        var newAreaSizes = []
        var areaSum = 0
        for(var i in this.fields){
            var field = this.fields[i]
            if(field.area)
                continue
            
            var area = new Area(field.color,this.model)
            this.model.fillNewArea(area,field.x,field.y)
            area.setFields()
            newAreas.push(area)
            newAreaSizes.push(area.fields.length)
            areaSum += area.fields.length
        }
        var oldmoney = this.money
        var allmoney = this.money
        for(var i in newAreas){
            var moneyToAdd = Math.ceil(newAreaSizes[i] * oldmoney / areaSum)
            
            if(allmoney <= 0)
                newAreas[i].money = 0
            else
                newAreas[i].money = Math.min(moneyToAdd,allmoney)
            allmoney -= moneyToAdd
            
        }
        newAreas.sort((a,b) => b.fields.length - a.fields.length)
        
        this.fields = newAreas[0].fields
        this.money = newAreas[0].money
        this.setFields()

        return newAreas.slice(1)
    }
    setFields(){
        this.villages = 0
        this.cities = 0
        this.mines = 0
        this.crosses = 0
        for(var i in this.fields){
            var field = this.fields[i]
            field.area = this
            switch(field.cityVillage){
                case 1: this.villages++; break
                case 2: this.mines++; break
                case 3: this.cities++; break
                case 4: this.crosses++; break
            }
        }
    }
    tryMerge(){
        var success = false
        var neighboringAreas = []
        for(var i in this.fields){
            var field = this.fields[i]
            
            var neighbors = Object.values(this.model.getDirectNeighborsWithDiagonals(field.x, field.y)).filter(x=>x!=null).map(x=>x.area).filter(x=>x != null && x != this)
            
            neighboringAreas.push(neighbors)
        }
        neighboringAreas = Array.from(new Set(neighboringAreas))
        for(var i in neighboringAreas){
            var neighboringArea = neighboringAreas[i]
            if(neighboringArea.color == this.color){
                this.fields = this.fields.concat(neighboringArea.fields)
                neighboringArea.fields = []
                this.money += neighboringArea.money
                neighboringArea.money = 0
                success = true
            }
        }
        if(success)
            this.tryMerge()
    }
    tryGiveMoney(){
        for(var i in this.fields){
            var field = this.fields[i]
            if(field.area != null && field.area != this && field.color == this.color){
                field.area.money += this.money
                this.money = 0
                break
            }
        }
    }
    
    redistribute(){
        this.money += this.moneySupply()
        this.people = this.peopleSupply()
        
        var foodToAdd = this.foodSupply()
        var units = this.fields.filter(x => x.unit != null).map(x => x.unit)
        for(var i = 0;i<units.length;i++){
            units[i].removeFood()
            units[i].paid = false
        }
        var shuffled = units.slice()
        shuffle(shuffled)
        
        for(var i = 0;i<shuffled.length;i++){
            //console.log(this.money,foodToAdd,shuffled[i].moneyDemand(),shuffled[i].foodDemand())
            if(this.money >= shuffled[i].moneyDemand() && foodToAdd >= shuffled[i].foodDemand()){
                shuffled[i].addFood()
                shuffled[i].paid = true
                this.money -= shuffled[i].moneyDemand()
                foodToAdd -= shuffled[i].foodDemand()
            } else {
                break
            }
        }
        for(var i in units){
            var unit = units[i]
            if(unit.food <= 0)
                unit.changeMorale(-3)
            else if(unit.food <= 1)
                unit.changeMorale(-2)
        }
    }
}
class Controller {
    constructor(ai){
        let th = this
        
        this.canvas = document.getElementById("canv")
        this.restartbutton = document.getElementById("restartbutton")
        this.nextturnbutton = document.getElementById("nextturnbutton")
        this.nextturnbutton2 = document.getElementById("nextturnbutton2")
        this.nextturnbutton3 = document.getElementById("nextturnbutton3")
        
        this.trucebutton = document.getElementById("trucebutton")
        this.numbertrucebuttons = {}
        for(var i=1;i<=9;i++){
            this.numbertrucebuttons[i] = document.getElementById("truce"+i)
        }
        this.stoptrucing = document.getElementById("stoptrucing")
        this.accepttruce = document.getElementById("accepttruce")
        this.rejecttruce = document.getElementById("rejecttruce")
        
        this.fortifybutton = document.getElementById("fortify")
        this.stopfortifyingbutton = document.getElementById("stopfortifying")
        
        //this.add1 = document.getElementById("add1")
        this.add5 = document.getElementById("add5")
        this.add10 = document.getElementById("add10")
        this.add50 = document.getElementById("add50")
        this.add99 = document.getElementById("add99")
        
        //this.changeadd1 = document.getElementById("changeadd1")
        this.changeadd5 = document.getElementById("changeadd5")
        this.changeadd10 = document.getElementById("changeadd10")
        this.changeadd50 = document.getElementById("changeadd50")
        this.changeadd99 = document.getElementById("changeadd99")
        
        
        this.upgradeunitbutton = document.getElementById("upgradeunitbutton")
        this.downgradeunitbutton = document.getElementById("downgradeunitbutton")
        this.upgradeunitbutton2 = document.getElementById("upgradeunitbutton2")
        this.downgradeunitbutton2 = document.getElementById("downgradeunitbutton2")
        
        this.stopupgrading = document.getElementById("stopupgrading")
        
        this.stopadding = document.getElementById("stopadding")
        
        //this.ssbutton = document.getElementById("ssbutton")
        //this.rsbutton = document.getElementById("rsbutton")

        this.generation = 0
        this.going = false
        
        this.ctx = this.canvas.getContext('2d')
        
        this.restartbutton.onclick = () => {th.restart()}
        this.nextturnbutton.onclick = () => {th.nextTurn()}
        this.nextturnbutton2.onclick = () => {th.nextTurn()}
        this.nextturnbutton3.onclick = () => {th.nextTurn()}
        
        //this.add1.onclick = () => {th.startAdding(1)}
        this.add5.onclick = () => {th.startAdding(5)}
        this.add10.onclick = () => {th.startAdding(10)}
        this.add50.onclick = () => {th.startAdding(50)}
        this.add99.onclick = () => {th.startAdding(99)}
        
        //this.changeadd1.onclick = () => {th.startAdding(1)}
        this.changeadd5.onclick = () => {th.startAdding(5)}
        this.changeadd10.onclick = () => {th.startAdding(10)}
        this.changeadd50.onclick = () => {th.startAdding(50)}
        this.changeadd99.onclick = () => {th.startAdding(99)}
        
        this.upgradeunitbutton.onclick = () => {th.updowngrade(1)}
        this.downgradeunitbutton.onclick = () => {th.updowngrade(-1)}
        this.upgradeunitbutton2.onclick = () => {th.updowngrade(1)}
        this.downgradeunitbutton2.onclick = () => {th.updowngrade(-1)}
        
        this.trucebutton.onclick = () => {th.startTrucing()}
        for(var i=1;i<=9;i++){
            let j = i
            this.numbertrucebuttons[i].onclick = () => {th.changeProposerTruceLength(j)}
        }
        
        
        
        this.stopadding.onclick = () => {th.backToPlaying()}
        this.stopupgrading.onclick = () => {th.backToPlaying()}
        this.stoptrucing.onclick = () => {th.backToPlaying()}
        
        this.accepttruce.onclick = () => {th.acceptTruce()}
        this.rejecttruce.onclick = () => {th.rejectTruce()}
        
        this.fortifybutton.onclick = () => {th.startFortifying()}
        this.stopfortifyingbutton.onclick = () => {th.backToPlaying()}
        
        this.savedState = null
        //this.ssbutton.onclick = () => {
        //    //this.savedState = th.model.saveState()
        //    this.savedState = th.model.copyModel()
        //}
        //this.rsbutton.onclick = () => {
        //    if(this.savedState != null){
        //        //th.model.restoreState(this.savedState,th.model)
        //        th.model = this.savedState.copyModel()
        //        th.draw()
        //    }
        //}
        
        this.prepareEvents()
        
        this.model = new Model()
        this.model.prepareBoard()
        
        
        this.addAi(ai)
        
        this.loop()
        this.draw()
    }
    addAi(ai){
        this.ai = ai
        ai.addModel(this.model)
    }
    updowngrade(way){
        this.model.updowngrade(way)
        this.draw()
    }
    startAdding(size){
        this.model.startAdding(size)
        this.draw()
    }
    startTrucing(){
        this.model.startTrucing()
        this.draw()
    }
    acceptTruce(){
        this.model.acceptTruce()
        this.draw()
    }
    rejectTruce(){
        this.model.rejectTruce()
        this.draw()
    }
    changeProposerTruceLength(i){
        this.model.changeProposerTruceLength(i)
        this.draw()
    }
    startFortifying(){
        this.model.startFortifying()
        this.draw()
    }
    backToPlaying(){
        this.model.acceptTruce()
        this.draw()
    }
    backToPlaying(){
        this.model.backToPlaying()
        this.draw()
    }
    restart(){
        this.model.prepareBoard()
        this.draw()
    }
    play(){
        
    }
    setGoing(){
        this.going = !this.going
    }
    loop(){
        if(this.going)
            this.move()
        let th = this
        setTimeout(()=>{th.loop()},40)
    }
    move(){
        this.generation++
        
        this.draw()
    }
    draw(x,y){
        if(x == undefined)
            this.ctx.clearRect(0,0,1000,1000)
        for(var i = 0;i<this.model.boardSize;i++){
            if(x!=undefined && i != x)
                continue
            for(var j = 0;j<this.model.boardSize;j++){
                if(y!=undefined && j != y)
                    continue
                this.model.board[i][j].draw(this.ctx)
            }
        }
        for(var i = 0;i<this.model.boardSize;i++){
            if(x!=undefined && i != x)
                continue
            for(var j = 0;j<this.model.boardSize;j++){
                if(this.model.board[i][j].unit){
                    if(y!=undefined && j != y)
                        continue
                    var glow = i == this.curx && j == this.cury
                    var unit = this.model.board[i][j].unit
                    var selected = this.model.selectedUnit == unit
                    var moveCount = selected ? this.model.multiplyMoveCount(this.model.selectedUnit.size,this.model.selectedUnitMoveCount) : unit.size
                    unit.draw(this.ctx, glow, selected, moveCount)
                }
            }
        }
        for(var i in this.model.selectedUnitLegalMoves){
            var move = this.model.selectedUnitLegalMoves[i]
            this.model.board[move.x][move.y].drawGlow(this.ctx)
        }
        this.updatePanel()
    }
    prepareEvents(){
        this.curx = 0
        this.cury = 0
        
		this.canvas.addEventListener("click",(e)=>this.clickEvent(e))
		this.canvas.addEventListener("mousedown",(e)=>this.mousedown(e))
		this.canvas.addEventListener("mousemove",(e)=>this.mousemove(e))
		this.canvas.addEventListener("mouseup",(e)=>this.mouseup(e))
    }
	getMouseEventCoords(e){
        var originalSize = 1000
		var rect = this.canvas.getBoundingClientRect()
		var x = Math.round((e.clientX - rect.left)*originalSize/rect.width)
		var y = Math.round((e.clientY - rect.top)*originalSize/rect.height)
		return {x: x, y: y}
	}
	
	coordsToSquares(x,y){
        var sqWidth = 1000/this.model.boardSize
        return {x:Math.floor(x / sqWidth), y:Math.floor(y / sqWidth)}
	}
	clickEvent(e){
            var { x, y } = this.getMouseEventCoords(e)
            var cu = this.coordsToSquares(x,y)

            switch(this.model.phase){
                case 0:
                    this.tryChooseUnit(cu.x,cu.y)
                break
                case 1:
                    this.trySelectUnit(cu.x,cu.y)
                break
                case 2:
                    this.tryPlaceUnit(cu.x,cu.y)
                break
                case 3:
                    this.tryUpDowngradeUnit(cu.x,cu.y)
                break
                case 4:
                    this.tryTruce(cu.x,cu.y)
                break
                case 6:
                    this.tryFortify(cu.x,cu.y)
                break
            }
	}
	mousedown(e){
            var { x, y } = this.getMouseEventCoords(e)
	}
	mousemove(e){
            var { x, y } = this.getMouseEventCoords(e)
            var cu = this.coordsToSquares(x,y)
            
            var oldcurx = this.curx
            var oldcury = this.cury
            this.curx = cu.x
            this.cury = cu.y
            if(this.curx != oldcurx || this.cury != oldcury){
                this.draw()
            }
	}
	mouseup(e){
            var { x, y } = this.getMouseEventCoords(e)
	}
	
	tryChooseUnit(x,y){
        if(this.model.board[x][y].unit){
            this.model.startGame(this.model.board[x][y].unit.color)
            this.draw()
        }
	}
	trySelectUnit(x,y){
        if(this.model.board[x][y].unit){
            var unit = this.model.board[x][y].unit
            if(this.model.selectedUnit != null && this.model.selectedUnit == unit){
                switch(this.model.selectedUnitMoveCount){
                    case 1: this.model.selectUnit(x,y,0.25); break
                    case 0.25: this.model.selectUnit(x,y,0.5); break
                    case 0.5: this.model.selectUnit(x,y,0.75); break
                    default: this.model.selectUnit(x,y,1) 
                }
            } else if(this.model.selectedUnit != null && unit.color == this.model.currentPlayer){
                this.model.moveUnit(this.model.selectedUnit.x,this.model.selectedUnit.y,x,y,this.model.selectedUnitMoveCount)
            } else if(this.model.selectedUnit != null){
                this.model.moveUnit(this.model.selectedUnit.x,this.model.selectedUnit.y,x,y,this.model.selectedUnitMoveCount)
            } else {
                if(unit.color == this.model.currentPlayer){
                    this.model.selectUnit(x,y,1)
                } else {
                    this.model.deselectUnit()
                }
            }
        } else {
            if(this.model.selectedUnitLegalMoves.filter(a => a.x == x && a.y == y).length > 0){
                this.model.moveUnit(this.model.selectedUnit.x,this.model.selectedUnit.y,x,y,this.model.selectedUnitMoveCount)
            } else {
                this.model.deselectUnit()
            }
        }
        this.draw()
	}
	tryPlaceUnit(x,y){
        this.model.tryPlaceUnit(x,y,this.model.addingSize)
        this.draw()
	}
	tryUpDowngradeUnit(x,y){
        this.model.tryUpDowngradeUnit(x,y,this.model.updowngradeWay)
        this.draw()
	}
	tryTruce(x,y){
        this.model.tryTruce(x,y,this.model.proposerTruceLength)
        this.draw()
	}
	tryFortify(x,y){
        this.model.tryFortify(x,y)
        this.draw()
	}
	nextTurn(){
        if(this.model.phase == 2 || this.model.phase == 3)
            this.model.backToPlaying()
        this.model.nextTurn()
        this.draw()
	}
	updatePanel(){
        for(var i = 0;i<=6;i++){
            var panel = document.getElementById('phase'+i)
            
            panel.style.display = this.model.phase == i ? 'block' : 'none'
        }
        var myAreas = this.model.areas.filter(x=>x.color == this.model.currentPlayer).sort((a,b)=>b.fields.length - a.fields.length)
        let th = this

        Array.from(document.getElementsByClassName('colordisplay')).forEach(x => x.style.backgroundColor = th.model.currentPlayer)
        Array.from(document.getElementsByClassName('colordisplay2')).forEach(x => x.style.backgroundColor = th.model.temporaryPlayer)


        switch(this.model.phase){
            case 1:
                var areasDiv = document.getElementById('areas')
                
                var html = ""
                for(var i in myAreas){
                    var area = myAreas[i]
                    html += this.makeAreaDiv(area)
                }
                
                areasDiv.innerHTML = html
            break
            case 2:

                document.getElementById('adding-amount').innerHTML = this.model.addingSize
                var astats = document.getElementById('adding-stats')
                var stats = ""
                for(var i in myAreas){
                    var area = myAreas[i]
                    stats += this.makeAreaDiv(area)
                }
                astats.innerHTML = stats
            break
            case 3:
                var updowngrading = document.getElementById('updowngrading')
                var updowngradingnotice = document.getElementById('updowngradingnotice')
                var udstats = document.getElementById('updowngrading-stats')
                var stats = ""
                for(var i in myAreas){
                    var area = myAreas[i]
                    stats += this.makeAreaDiv(area)
                }
                udstats.innerHTML = stats
                switch(this.model.updowngradeWay){
                    case -1:
                        updowngrading.innerHTML = "DOWNGRADE UNIT"
                        updowngradingnotice.innerHTML = "Note: morale will fall drastically, but funding will lift"
                    break
                    case 1:
                        updowngrading.innerHTML = "UPGRADE UNIT"
                        updowngradingnotice.innerHTML = "Note: morale will jump and low limit of morale will be raised.<br/><br/>Non-upgraded unit costs 1$ per turn.<br/>1-level upgraded unit costs 2$ per turn.<br/>2-level upgraded unit costs 3$ per turn."
                    break
                }
            break
            case 4:
                var trucelengthElement = document.getElementById('trucelength')
                trucelengthElement.innerHTML = this.model.proposerTruceLength + ' turn' + (this.model.proposerTruceLength == 1 ? '' : 's')
            break
            case 5:
                var element = document.getElementById('proposal')
                proposal.innerHTML = "Player offered truce for "+this.model.proposerTruceLength+" turns."
            break
            case 6:
                var udstats = document.getElementById('fortyfying-stats')
                var stats = ""
                for(var i in myAreas){
                    var area = myAreas[i]
                    stats += this.makeAreaDiv(area)
                }
                udstats.innerHTML = stats
                
            break
        }
	}
	makeAreaDiv(area){
        var foodScarce = area.foodDemand() > area.foodSupply()
        var moneyScarce = area.moneyDemand() > area.moneySupply()
        
        var foodDiv = foodScarce
            ? '<span class="redspan">Food demand: '+area.foodDemand()+'</span><br/>'
            : 'Food demand: '+area.foodDemand()+'<br/>'
            
        var moneyDiv = moneyScarce
            ? '<span class="redspan">Money demand: '+area.moneyDemand()+'</span><br/>'
            : 'Money demand: '+area.moneyDemand()+'<br/>'
        return '<div class="borderedDiv"><b>Area #'+area.number+'</b><br/>Fields: '+area.fields.length+'<br/><br/>Money: '+area.money+'<br/>'+foodDiv+moneyDiv+'<br/>New people: '+area.people+'<br/>Food supply: '+area.foodSupply()+'<br/>Money supply: '+area.moneySupply()+'</div>'
	}
}
const MAX_PIECES = 11
function init(){
    var ai = new Ai
    var controller = new Controller(ai)
}

class Ai {
    constructor(){
    }
    addModel(model){
        this.model = model
        
        this.testDebug()
    }
    testDebug(){
        var firstCity = this.model.allLands.filter(x=>x.unit != null)[0]
        var debugMap = this.model.getUnitLegalMovesForMoreTurns(firstCity.x,firstCity.y,20)
        var cities = this.model.allLands.filter(x=>x.unit != null)
        for(var i in cities){
            debugMap = this.model.getUnitLegalMovesForMoreTurns(cities[i].x,cities[i].y,20)
            for(var i in debugMap){
                var move = debugMap[i]
                //if(this.model.board[move.x][move.y].debug == null || this.model.board[move.x][move.y].debug>move.turn)
                //    this.model.board[move.x][move.y].debug = move.turn
            }
        }

    }
}
</script> 
</head>
<body>
<div id="whole">
<canvas id="canv" width="1000" height="1000">
</canvas>
<div id="panel">
    SUSTAINABLE WAR
    <hr/>
    <div id="phase0">
        <input type="button" id="restartbutton" value="SHUFFLE">
        <br/>
        CLICK UNIT TO CHOOSE TEAM
    </div>
    <div id="phase1">
        <!--input type="button" id="restartbutton" value="SHUFFLE"-->
        PLAYER:
        <div class="colordisplay"></div>
        <br/>
        <input type="button" id="nextturnbutton" value="NEXT TURN">
        <input type="button" id="trucebutton" value="OFFER TRUCE">
        
        
        <!--input type="button" id="ssbutton" value="SAVE STATE">
        <input type="button" id="rsbutton" value="RESTORE STATE"-->
        <hr/>
        ADD UNITS:
        <!--input type="button" id="add1" value="+1"-->
        <input type="button" id="add5" value="+5">
        <input type="button" id="add10" value="+10">
        <input type="button" id="add50" value="+50">
        <input type="button" id="add99" value="+99">
        <br/>
        (1 money, 1 people for 1 soldier)
        <br/>

        <input type="button" id="upgradeunitbutton" value="FUND UNIT">
        <input type="button" id="downgradeunitbutton" value="DEFUND UNIT">
        (morale boost and keep)
        <hr/>
        FORTIFICATIONS:<br/>
        <input type="button" id="fortify" value="FORTIFY">
        <hr/>
        AREAS:
        <div id="areas"></div>

    </div>
    <div id="phase2">
        PLAYER:
        <div class="colordisplay"></div>
        <br/>
        ADDING <span id="adding-amount"></span> TROOPS
        <br/>
        
        CHANGE QUANTITY:
        <!--input type="button" id="changeadd1" value="+1"-->
        <input type="button" id="changeadd5" value="+5">
        <input type="button" id="changeadd10" value="+10">
        <input type="button" id="changeadd50" value="+50">
        <input type="button" id="changeadd99" value="+99">

        <br/><br/>
        <input type="button" id="stopadding" value="STOP ADDING">
        <input type="button" id="nextturnbutton2" value="NEXT TURN">
        <hr/>
        AREAS:
        <div id="adding-stats"></div>
    </div>
    <div id="phase3">
        PLAYER:
        <div class="colordisplay"></div>
        <br/>
        <div id="updowngrading"></div>
        <input type="button" id="upgradeunitbutton2" value="FUND UNIT">
        <input type="button" id="downgradeunitbutton2" value="DEFUND UNIT">
        <input type="button" id="stopupgrading" value="STOP UPGRADING">
        <hr/>
        <input type="button" id="nextturnbutton3" value="NEXT TURN">
        <hr/>
        <div id="updowngradingnotice"></div>
        AREAS:
        <div id="updowngrading-stats"></div>
    </div>
    <div id="phase4">
        PLAYER:
        <div class="colordisplay"></div>
        <br/>
        CHOOSE PLAYER ON TO TRUCE WITH
        <br/>
        <input type="button" id="stoptrucing" value="RESIGN">
        <hr/>
        NUMBER OF TURNS WITH TRUCE:
        <br/>
        <input type="button" id="truce1" value="&nbsp;1&nbsp;" />
        <input type="button" id="truce2" value="&nbsp;2&nbsp;" />
        <input type="button" id="truce3" value="&nbsp;3&nbsp;" />
        <br/>
        <input type="button" id="truce4" value="&nbsp;4&nbsp;" />
        <input type="button" id="truce5" value="&nbsp;5&nbsp;" />
        <input type="button" id="truce6" value="&nbsp;6&nbsp;" />
        <br/>
        <input type="button" id="truce7" value="&nbsp;7&nbsp;" />
        <input type="button" id="truce8" value="&nbsp;8&nbsp;" />
        <input type="button" id="truce9" value="&nbsp;9&nbsp;" />
        <br/>
        Propose <span id="trucelength"></span>
        <br/>

    </div>
    <div id="phase5">
        PLAYER:
        <div class="colordisplay"></div>
        <br/>
        PLAYER WHO PROPOSED TRUCE:
        <div class="colordisplay2"></div>
        <br/>
        <span id="proposal"></span>
        <br/>
        Do you accept?<br/>
        <input type="button" id="accepttruce" value="ACCEPT"><br/>
        <input type="button" id="rejecttruce" value="REJECT">
    </div>
    <div id="phase6">
        PLAYER:
        <div class="colordisplay"></div>
        <br/>
        Choose places outside towns to fortify.<br/>
        Cost: 50$ for area.<br/>
        Stops 
        <br/>
        <input type="button" id="stopfortifying" value="STOP FORTIFYING">
        <br/>
        AREAS:
        <div id="fortyfying-stats"></div>
        
    </div>
</div>
<script>
	init();
</script>
</body>
</html>
